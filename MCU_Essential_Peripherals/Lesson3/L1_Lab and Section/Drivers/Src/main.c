/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "stm32f103x6.h"
#include "STM32_F103C6_GPIO_Driver.h"
#include "LCD.h"
#include "keypad.h"
#include "SevenSegmentComAnode.h"

typedef volatile unsigned int vuint32_t;


void clock_init()
{
	//Enable clock GPIOA
	RCC_GPIOA_CLK_EN();
	// Enable clock GPIOB
	RCC_GPIOB_CLK_EN();
}

void GPIOA_init()
{
	GPIO_PinConfig_t PinConfig;
	// ================= PA1 =================
	PinConfig.GPIO_PIN = GPIO_PIN_1;
	PinConfig.GPIO_MODE = GPIO_MODE_INPUT_FLO;
	MCAL_GPIO_Init(GPIOA, &PinConfig);

	// ================= PA13 =================
	PinConfig.GPIO_PIN = GPIO_PIN_13;
	PinConfig.GPIO_MODE = GPIO_MODE_INPUT_FLO;
	MCAL_GPIO_Init(GPIOA, &PinConfig);

}

void GPIOB_init()
{
	GPIO_PinConfig_t PinConfig;
	// ================= PB1 =================
	PinConfig.GPIO_PIN = GPIO_PIN_1;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);


	// ================= PB13 =================
	//	PinConfig.GPIO_PIN = GPIO_PIN_13;
	//	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	//	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	//	MCAL_GPIO_Init(GPIOB, &PinConfig);
	// =================================================================

	PinConfig.GPIO_PIN = GPIO_PIN_9;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);

	PinConfig.GPIO_PIN = GPIO_PIN_10;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);

	PinConfig.GPIO_PIN = GPIO_PIN_11;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);

	PinConfig.GPIO_PIN = GPIO_PIN_12;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);

	PinConfig.GPIO_PIN = GPIO_PIN_13;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);


	PinConfig.GPIO_PIN = GPIO_PIN_14;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);


	PinConfig.GPIO_PIN = GPIO_PIN_15;
	PinConfig.GPIO_MODE = GPIO_MODE_OUTPUT_PP;
	PinConfig.GPIO_Output_Speed = GPIO_SPEED_10M;
	MCAL_GPIO_Init(GPIOB, &PinConfig);

}
unsigned char SS_Values[] = {SS_ZERO, SS_ONE, SS_TWO, SS_THREE, SS_FOUR, SS_FIVE, SS_SIX, SS_SEVEN, SS_EIGHT, SS_NINE};

int main(void)
{
	//	clock_init();
	//	GPIOA_init();
	//	GPIOB_init();
	//
	//	int prev_input = 1;
	//    /* Loop forever */
	//	while(1)
	//	{
	//		if( ((MCAL_GPIO_ReadPin(GPIOA, GPIO_PIN_1) ) == 0) ) // Press
	//		{
	//			if (prev_input == 1)
	//			{
	//				MCAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);
	//				prev_input = 0;
	//			}
	//		}
	//		else
	//			prev_input = 1;
	//		if( (MCAL_GPIO_ReadPin(GPIOA, GPIO_PIN_13) ) == 1) // Multi Press
	//		{
	//			MCAL_GPIO_TogglePin(GPIOB, GPIO_PIN_13);
	//		}
	//		delay(10);
	//	}

	clock_init();

	LCD_INIT();
	delay(50);
	Keypad_init();


	GPIOB_init();
	unsigned char number;
	uint32_t key;
	LCD_Write_String("Hey There");
	delay(500);
	LCD_CLear_Screen();
	int count = 0;
		WriteOn_7Seg(SS_Values[0]);
	while(1)
	{

		if (count == 16)
		{
			LCD_GotoXY(1,0);
		}
		else if (count >= 32)
		{
			LCD_CLear_Screen();
			LCD_GotoXY(0,0);
			count = 0;
		}
		key = Keypad_getkey();
		if (key != 'N') {
			LCD_Write_Char(key);

			if ( (key >= '0')) {
				if ((key <= '9')) {
					number = key - '0';
					WriteOn_7Seg(SS_Values[number]);
					count++;
				}

			}
		}
	}
}
